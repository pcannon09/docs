.TH "vp::Parser" 3 "Version v1.0.0-build" "varpar.cpp" \" -*- nroff -*-
.ad l
.nh
.SH NAME
vp::Parser
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <VP_Parse\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBParser\fP (const std::string &_id, const std::string &_file, const std::string &_extension='\&.varpar')"
.br
.RI "Create the object, set errors if there are and set some configuration from the parameters\&. "
.ti -1c
.RI "\fB~Parser\fP ()"
.br
.RI "Deconstructor\&. "
.ti -1c
.RI "\fBParserStatus\fP \fBcheckStatus\fP () const"
.br
.RI "Get the constructed starts\&. "
.ti -1c
.RI "std::string \fBgetID\fP () const"
.br
.RI "Get the current object ID\&. "
.ti -1c
.RI "std::string \fBgetVal\fP (const std::string &_key) const"
.br
.RI "Get value of _key\&. "
.ti -1c
.RI "\fBParserReturn\fP \fBparse\fP ()"
.br
.RI "Public API wrapper for \fR\fBParser::__parse()\fP\fP function\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBParserReturn\fP \fB__parse\fP ()"
.br
.RI "Private member of the parse function\&. "
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::string \fBextension\fP"
.br
.ti -1c
.RI "std::string \fBfpath\fP"
.br
.ti -1c
.RI "std::string \fBid\fP"
.br
.ti -1c
.RI "\fBParserReturn\fP \fBparseRet\fP"
.br
.ti -1c
.RI "\fBParserStatus\fP \fBstatus\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB35\fP of file \fBVP_Parse\&.hpp\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "vp::Parser::Parser (const std::string & _id, const std::string & _file, const std::string & _extension = \fR'\&.varpar'\fP)"

.PP
Create the object, set errors if there are and set some configuration from the parameters\&. 
.PP
\fBParameters\fP
.RS 4
\fI_id\fP Set the ID of the object 
.br
\fI_file\fP Set the path of the file 
.br
\fI_extension\fP Set the file extension 
.RE
.PP

.PP
Definition at line \fB16\fP of file \fBVP_Parse\&.cpp\fP\&.
.nf
17         : id(_id), fpath(_file), extension(_extension)
18     {
19         if (!fs::exists(_file))
20         {
21             const std::string &error = __VP_ERROR_THROW_DEFAULT_MSG + _file + " : Does not exist";
22 
23             std::cerr << error << "\\n";
24 
25             this\->status\&.error = error;
26             this\->status\&.constructed = false;
27 
28             return;
29         }
30 
31         const std::string &extensionSubstr = this\->fpath\&.substr(fpath\&.size() \- _extension\&.size());
32 
33         if (extensionSubstr != _extension)
34         {
35             const std::string &error = __VP_ERROR_THROW_DEFAULT_MSG + _file + " : Does not have the required file extension, required is: " + _extension;
36 
37             std::cerr << error << "\\n";
38 
39             this\->status\&.error = error;
40             this\->status\&.constructed = false;
41             
42             return;
43         }
44 
45         this\->status\&.constructed = true;
46     }
.PP
.fi

.PP
References \fB__VP_ERROR_THROW_DEFAULT_MSG\fP, \fBextension\fP, \fBfpath\fP, \fBid\fP, and \fBstatus\fP\&.
.SS "vp::Parser::~Parser ()"

.PP
Deconstructor\&. 
.SH "Member Function Documentation"
.PP 
.SS "\fBParserReturn\fP vp::Parser::__parse ()\fR [protected]\fP, \fR [virtual]\fP"

.PP
Private member of the parse function\&. 
.PP
\fBReturns\fP
.RS 4
\fBParserReturn\fP Parsed information 
.RE
.PP

.PP
Definition at line \fB55\fP of file \fBVP_Parse\&.cpp\fP\&.
.nf
56     {
57         std::vector<std::string> output;
58 
59         std::map<std::string, std::string> conf;
60         std::ifstream file(this\->fpath);
61         std::string line;
62 
63         ssize_t lineNum = 0;
64 
65         while (std::getline(file, line))
66         {
67             lineNum++;
68 
69             // Skip if comment or empty line
70             if (line\&.empty() || line[0] == ';') continue;
71 
72             std::istringstream iss(line);
73             std::string key, val;
74 
75             if (std::getline(iss, key, '=') && std::getline(iss, val))
76             {
77                 key\&.erase(0, key\&.find_first_not_of(" \\t"));
78                 key\&.erase(key\&.find_last_not_of(" \\t") + 1);
79 
80                 val\&.erase(0, val\&.find_first_not_of(" \\t"));
81                 val\&.erase(val\&.find_last_not_of(" \\t") + 1);
82 
83                 if (conf\&.find(key) != conf\&.end())
84                 {
85                     output\&.emplace_back(std::string("ERR: LINE: " + std::to_string(lineNum)));
86                     output\&.emplace_back("Duplicate member : " + line);
87 
88                     return { conf, output, false };
89                 }
90 
91                 conf[key] = val;
92             }
93 
94             else
95             {
96                 output\&.emplace_back(std::string("ERR: LINE: " + std::to_string(lineNum)));
97                 output\&.emplace_back(std::string("No equality operator to set value for `" + line + "`"));
98 
99                 return { conf, output, false };
100             }
101         }
102 
103         return { conf, output, true };
104     }
.PP
.fi

.PP
References \fBfpath\fP\&.
.PP
Referenced by \fBparse()\fP\&.
.SS "\fBParserStatus\fP vp::Parser::checkStatus () const"

.PP
Get the constructed starts\&. 
.PP
\fBReturns\fP
.RS 4
\fBParserStatus\fP 
.RE
.PP

.PP
Definition at line \fB114\fP of file \fBVP_Parse\&.cpp\fP\&.
.nf
115     { return this\->status; }
.PP
.fi

.PP
References \fBstatus\fP\&.
.SS "std::string vp::Parser::getID () const"

.PP
Get the current object ID\&. 
.PP
\fBReturns\fP
.RS 4
std::string Current object ID 
.RE
.PP

.PP
Definition at line \fB117\fP of file \fBVP_Parse\&.cpp\fP\&.
.nf
118     { return this\->id; }
.PP
.fi

.PP
References \fBid\fP\&.
.SS "std::string vp::Parser::getVal (const std::string & _key) const"

.PP
Get value of _key\&. 
.PP
\fBParameters\fP
.RS 4
\fI_key\fP Key value to find 
.RE
.PP
\fBReturns\fP
.RS 4
std::string Return the value 
.RE
.PP

.PP
Definition at line \fB106\fP of file \fBVP_Parse\&.cpp\fP\&.
.nf
107     {
108         if (this\->parseRet\&.config\&.find(_key) != this\->parseRet\&.config\&.end())
109             return this\->parseRet\&.config\&.at(_key);
110 
111         return "";
112     }
.PP
.fi

.PP
References \fBparseRet\fP\&.
.SS "\fBParserReturn\fP vp::Parser::parse ()"

.PP
Public API wrapper for \fR\fBParser::__parse()\fP\fP function\&. 
.PP
\fBReturns\fP
.RS 4
\fBParserReturn\fP Parsed information 
.RE
.PP

.PP
Definition at line \fB48\fP of file \fBVP_Parse\&.cpp\fP\&.
.nf
49     {
50         this\->parseRet = this\->__parse();
51 
52         return this\->parseRet;
53     }
.PP
.fi

.PP
References \fB__parse()\fP, and \fBparseRet\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "std::string vp::Parser::extension\fR [private]\fP"

.PP
Definition at line \fB44\fP of file \fBVP_Parse\&.hpp\fP\&.
.PP
Referenced by \fBParser()\fP\&.
.SS "std::string vp::Parser::fpath\fR [private]\fP"

.PP
Definition at line \fB39\fP of file \fBVP_Parse\&.hpp\fP\&.
.PP
Referenced by \fBParser()\fP, and \fB__parse()\fP\&.
.SS "std::string vp::Parser::id\fR [private]\fP"

.PP
Definition at line \fB38\fP of file \fBVP_Parse\&.hpp\fP\&.
.PP
Referenced by \fBParser()\fP, and \fBgetID()\fP\&.
.SS "\fBParserReturn\fP vp::Parser::parseRet\fR [private]\fP"

.PP
Definition at line \fB42\fP of file \fBVP_Parse\&.hpp\fP\&.
.PP
Referenced by \fBgetVal()\fP, and \fBparse()\fP\&.
.SS "\fBParserStatus\fP vp::Parser::status\fR [private]\fP"

.PP
Definition at line \fB41\fP of file \fBVP_Parse\&.hpp\fP\&.
.PP
Referenced by \fBParser()\fP, and \fBcheckStatus()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for varpar\&.cpp from the source code\&.
