.TH "fsi::Indexer" 3 "Version v0.1.2-beta" "FileSystemIndexer" \" -*- nroff -*-
.ad l
.nh
.SH NAME
fsi::Indexer
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <FSI_Indexer\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBIndexer\fP (const std::string &\fBid\fP, const bool \fBthreadsImpl\fP=false)"
.br
.ti -1c
.RI "\fB~Indexer\fP ()"
.br
.ti -1c
.RI "\fBIndexerError\fP \fBaddExtendedInfo\fP (const \fBIndexerInfo\fP &info)"
.br
.RI "Add the exact path and the sub-paths to have the info from;\&. "
.ti -1c
.RI "\fBIndexerError\fP \fBaddInfo\fP (const \fBIndexerInfo\fP &info)"
.br
.RI "Add the exact path to have the info from\&. "
.ti -1c
.RI "\fBIndexerInfo\fP \fBfindIndex\fP (const std::string &toFind)"
.br
.RI "Find the index from the vector database from the indexer\&. "
.ti -1c
.RI "\fButils::TimeUtils_DateTime\fP \fBgetFileDTInfo\fP (const std::string &path)"
.br
.RI "Get when the file, dir or symlink was last modified\&. "
.ti -1c
.RI "std::string \fBgetID\fP () const"
.br
.RI "Get this object's ID\&. "
.ti -1c
.RI "std::vector< \fBIndexerInfo\fP > \fBgetIndexerInfo\fP () const"
.br
.RI "Return indexer information from this object\&. "
.ti -1c
.RI "std::vector< std::string > \fBgetIndexPaths\fP () const"
.br
.RI "Get all the indexed paths from the vector indexes\&. "
.ti -1c
.RI "\fBIndexerError\fP \fBremoveInfo\fP (const std::string &searcher)"
.br
.RI "Remove information from its ID or full path\&. "
.ti -1c
.RI "std::string \fBsearchExactMatching\fP (const std::string &find)"
.br
.RI "Search for an exact matching path or ID;\&. "
.ti -1c
.RI "std::vector< std::string > \fBsearchMatching\fP (const std::string &path)"
.br
.RI "Either use threaded or unthreaded search matching\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "virtual \fBIndexerError\fP \fB__addExtendedInfoStandard\fP (const \fBIndexerInfo\fP &info)"
.br
.RI "Standard non-threaded extended information\&. "
.ti -1c
.RI "virtual \fBIndexerError\fP \fB__addExtendedInfoThreaded\fP (const \fBIndexerInfo\fP &info)"
.br
.RI "Threaded extended information\&. "
.ti -1c
.RI "virtual \fBIndexerPathType\fP \fB__getPathType\fP (const std::string &path) const"
.br
.RI "Get if path from function param is a: "
.ti -1c
.RI "virtual std::vector< std::string > \fB__iteratePath\fP (const std::string &path)"
.br
.RI "Iterate all the files and directories (symlinks too) from \fRpath\fP\&. "
.ti -1c
.RI "virtual std::vector< std::string > \fB__searchMatchingStandard\fP (const std::string &find)"
.br
.RI "Search all matching path or ID that contains \fRpath\fP\&. "
.ti -1c
.RI "virtual std::vector< std::string > \fB__searchMatchingThreaded\fP (const std::string &find)"
.br
.RI "Search all matching path or ID that contains \fRpath\fP using parallelization with multiple CPU threads\&. "
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "static std::vector< std::vector< std::string > > \fB__splitPathByCores\fP (const std::vector< std::string > &paths)"
.br
.RI "Split the paths found to be used in the future in different CPU cores\&. "
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::string \fBid\fP"
.br
.ti -1c
.RI "std::vector< \fBIndexerInfo\fP > \fBindexerInfo\fP"
.br
.ti -1c
.RI "bool \fBthreadsImpl\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB60\fP of file \fBFSI_Indexer\&.hpp\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "fsi::Indexer::Indexer (const std::string & id, const bool threadsImpl = \fRfalse\fP)"

.PP
Definition at line \fB167\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
168         : id(id), threadsImpl(threadsImpl)
169     { }
.PP
.fi

.PP
References \fBIndexer()\fP, \fBid\fP, and \fBthreadsImpl\fP\&.
.PP
Referenced by \fBIndexer()\fP\&.
.SS "fsi::Indexer::~Indexer ()"

.PP
Definition at line \fB172\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
173     { }
.PP
.fi

.SH "Member Function Documentation"
.PP 
.SS "\fBIndexerError\fP fsi::Indexer::__addExtendedInfoStandard (const \fBIndexerInfo\fP & info)\fR [protected]\fP, \fR [virtual]\fP"

.PP
Standard non-threaded extended information\&. 
.IP "\(bu" 2
This will not add multiple extended information to be processed 
.PP
\fBParameters\fP
.RS 4
\fIinfo\fP Get the information from the exact path and deeper 
.RE
.PP
\fBReturns\fP
.RS 4
\fBIndexerError\fP Return error or success from \fR\fBIndexerError\fP\fP type 
.RE
.PP

.PP

.PP
Definition at line \fB69\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
70     {
71         IndexerError error = this\->addInfo(info);
72         IndexerInfo totalInfo = info;
73 
74         if (__FSI_INDEXERERR_CHECK(error))
75             return error;
76 
77         const std::vector<std::string> iteratedPaths = this\->__iteratePath(info\&.path);
78 
79         for (const auto &x : iteratedPaths)
80         {
81             totalInfo\&.pathType = this\->__getPathType(totalInfo\&.path);
82             totalInfo\&.path = x;
83 
84             this\->indexerInfo\&.emplace_back(totalInfo);
85         }
86 
87         return error;
88     }
.PP
.fi

.PP
References \fB__addExtendedInfoStandard()\fP, \fB__FSI_INDEXERERR_CHECK\fP, \fB__getPathType()\fP, \fB__iteratePath()\fP, \fBaddInfo()\fP, \fBindexerInfo\fP, \fBfsi::IndexerInfo::path\fP, and \fBfsi::IndexerInfo::pathType\fP\&.
.PP
Referenced by \fB__addExtendedInfoStandard()\fP, and \fBaddExtendedInfo()\fP\&.
.SS "\fBIndexerError\fP fsi::Indexer::__addExtendedInfoThreaded (const \fBIndexerInfo\fP & info)\fR [protected]\fP, \fR [virtual]\fP"

.PP
Threaded extended information\&. 
.IP "\(bu" 2
This will add multiple extended information to be processed in the future 
.PP
\fBParameters\fP
.RS 4
\fIinfo\fP Get the information from the exact path and deeper 
.RE
.PP
\fBReturns\fP
.RS 4
\fBIndexerError\fP Return error or success from \fR\fBIndexerError\fP\fP type 
.RE
.PP

.PP

.PP
Definition at line \fB90\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
91     {
92         IndexerError error = this\->addInfo(info);
93 
94         if (__FSI_INDEXERERR_CHECK(error))
95             return error;
96 
97         const auto paths = this\->__iteratePath(info\&.path);
98         const auto &chunks = this\->__splitPathByCores(paths);
99 
100         std::vector<std::future<std::vector<IndexerInfo>>> tasks;
101 
102         for (auto &chunk : chunks)
103         {
104             if (chunk\&.empty())
105                 continue;
106 
107             tasks\&.emplace_back(std::async(std::launch::async,
108                         [&, chunk]() \-> std::vector<IndexerInfo>
109             {
110                 std::vector<IndexerInfo> local;
111 
112                 local\&.reserve(chunk\&.size());
113 
114                 for (const auto &p : chunk)
115                 {
116                     IndexerInfo tmp = info;
117                     tmp\&.path = p;
118                     tmp\&.pathType = this\->__getPathType(p);
119                     local\&.emplace_back(std::move(tmp));
120                 }
121 
122                 return local;
123             }));
124         }
125 
126         // Merging phase
127         for (auto &t : tasks)
128         {
129             auto local = t\&.get();
130 
131             this\->indexerInfo\&.insert(
132                     this\->indexerInfo\&.end(),
133                     std::make_move_iterator(local\&.begin()),
134                     std::make_move_iterator(local\&.end()));
135         }
136 
137         return error;
138     }
.PP
.fi

.PP
References \fB__addExtendedInfoThreaded()\fP, \fB__FSI_INDEXERERR_CHECK\fP, \fB__getPathType()\fP, \fB__iteratePath()\fP, \fB__splitPathByCores()\fP, \fBaddInfo()\fP, \fBindexerInfo\fP, \fBfsi::IndexerInfo::path\fP, and \fBfsi::IndexerInfo::pathType\fP\&.
.PP
Referenced by \fB__addExtendedInfoThreaded()\fP, and \fBaddExtendedInfo()\fP\&.
.SS "\fBIndexerPathType\fP fsi::Indexer::__getPathType (const std::string & path) const\fR [protected]\fP, \fR [virtual]\fP"

.PP
Get if path from function param is a: 
.IP "\(bu" 2
File
.IP "\(bu" 2
Dir
.IP "\(bu" 2
SymLink
.IP "\(bu" 2
Others 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP Path to get the type from 
.RE
.PP
\fBReturns\fP
.RS 4
\fBIndexerPathType\fP The type of the function param 
.RE
.PP

.PP

.PP
Definition at line \fB20\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
21     {
22         if (fs::is_directory(path)) return IndexerPathType::Directory;
23         else if (fs::is_symlink(path)) return IndexerPathType::SymLink;
24 
25         return IndexerPathType::File;
26     }
.PP
.fi

.PP
References \fBfsi::Directory\fP, \fBfsi::File\fP, and \fBfsi::SymLink\fP\&.
.PP
Referenced by \fB__addExtendedInfoStandard()\fP, \fB__addExtendedInfoThreaded()\fP, and \fBaddInfo()\fP\&.
.SS "std::vector< std::string > fsi::Indexer::__iteratePath (const std::string & path)\fR [protected]\fP, \fR [virtual]\fP"

.PP
Iterate all the files and directories (symlinks too) from \fRpath\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP Path to iterate 
.RE
.PP
\fBReturns\fP
.RS 4
A tree of full path in a vector of strings 
.RE
.PP

.PP
Definition at line \fB140\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
141     {
142         std::vector<std::string> paths;
143 
144         CVEC tmpPathsVec = cvec_init(\-1, sizeof(char*));
145 
146         fsi_walk(&tmpPathsVec, path\&.c_str());
147 
148         for (size_t i = 0; i < tmpPathsVec\&.size; ++i)
149         {
150             char* p = *(char**)cvec_get(&tmpPathsVec, i);
151 
152             if (p)
153             {
154                 paths\&.emplace_back(p, strlen(p));
155 
156                 FSI_FREE(p);
157             }
158         }
159 
160         cvec_destroy(&tmpPathsVec);
161 
162         return paths;
163     }
.PP
.fi

.PP
References \fB__iteratePath()\fP, \fBFSI_FREE\fP, and \fBfsi_walk()\fP\&.
.PP
Referenced by \fB__addExtendedInfoStandard()\fP, \fB__addExtendedInfoThreaded()\fP, and \fB__iteratePath()\fP\&.
.SS "std::vector< std::string > fsi::Indexer::__searchMatchingStandard (const std::string & find)\fR [protected]\fP, \fR [virtual]\fP"

.PP
Search all matching path or ID that contains \fRpath\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP Path or ID to search 
.RE
.PP
\fBReturns\fP
.RS 4
A vector of all the found \fRpath\fPs 
.RE
.PP

.PP
Definition at line \fB28\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
29     {
30         if (find\&.empty())
31             return {};
32 
33         std::vector<std::string> vec;
34 
35         for (const auto &x : this\->indexerInfo)
36         {
37             if (x\&.path\&.find(find) != std::string::npos)
38                 vec\&.emplace_back(x\&.path);
39         }
40 
41         return vec;
42     }
.PP
.fi

.PP
References \fBindexerInfo\fP\&.
.PP
Referenced by \fBsearchMatching()\fP\&.
.SS "std::vector< std::string > fsi::Indexer::__searchMatchingThreaded (const std::string & find)\fR [protected]\fP, \fR [virtual]\fP"

.PP
Search all matching path or ID that contains \fRpath\fP using parallelization with multiple CPU threads\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP Path or ID to search 
.RE
.PP
\fBReturns\fP
.RS 4
A vector of all the found \fRpath\fPs 
.RE
.PP

.PP
Definition at line \fB44\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
45     {
46         if (find\&.empty())
47             return {};
48 
49         std::vector<std::string> result;
50         std::mutex mutex;
51 
52         std::for_each(
53                 std::execution::par,
54                 indexerInfo\&.begin(),
55                 indexerInfo\&.end(),
56                 [&](const auto& x)
57             {
58                 if (x\&.path\&.find(find) != std::string::npos)
59                 {
60                     std::lock_guard<std::mutex> lock(mutex);
61                     result\&.emplace_back(x\&.path);
62                 }
63             }
64         );
65 
66         return result;
67     }
.PP
.fi

.PP
References \fBindexerInfo\fP\&.
.PP
Referenced by \fBsearchMatching()\fP\&.
.SS "std::vector< std::vector< std::string > > fsi::Indexer::__splitPathByCores (const std::vector< std::string > & paths)\fR [inline]\fP, \fR [static]\fP, \fR [protected]\fP"

.PP
Split the paths found to be used in the future in different CPU cores\&. 
.IP "\(bu" 2
Split the vector in to tiny vectors depending on how many CPU cores the hardware has 
.PP
\fBParameters\fP
.RS 4
\fIpaths\fP The paths to split according to CPU cores 
.RE
.PP
\fBReturns\fP
.RS 4
Return the splitted paths 
.RE
.PP

.PP

.PP
Definition at line \fB124\fP of file \fBFSI_Indexer\&.hpp\fP\&.
.nf
125         {
126             const unsigned int threads = std::max(1u, std::thread::hardware_concurrency());
127 
128             std::vector<std::vector<std::string>> chunks(threads);
129 
130             for (size_t i = 0; i < paths\&.size(); ++i)
131                 chunks[i % threads]\&.push_back(paths[i]);
132 
133             return chunks;
134         }
.PP
.fi

.PP
Referenced by \fB__addExtendedInfoThreaded()\fP\&.
.SS "\fBIndexerError\fP fsi::Indexer::addExtendedInfo (const \fBIndexerInfo\fP & info)"

.PP
Add the exact path and the sub-paths to have the info from;\&. 
.IP "\(bu" 2
Use \fR\fBIndexer::__addExtendedInfoStandard()\fP\fP or \fR\fBIndexer::__addExtendedInfoThreaded()\fP\fP if threads are disabled or enabled 
.PP
\fBParameters\fP
.RS 4
\fIinfo\fP Get the information from the exact path and deeper 
.RE
.PP
\fBReturns\fP
.RS 4
\fBIndexerError\fP Return error or success from \fR\fBIndexerError\fP\fP type 
.RE
.PP

.PP

.PP
Definition at line \fB175\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
176     {
177         if (this\->threadsImpl)
178             return this\->__addExtendedInfoThreaded(info);
179         
180         return this\->__addExtendedInfoStandard(info);
181     }
.PP
.fi

.PP
References \fB__addExtendedInfoStandard()\fP, \fB__addExtendedInfoThreaded()\fP, and \fBthreadsImpl\fP\&.
.PP
Referenced by \fBmain()\fP\&.
.SS "\fBIndexerError\fP fsi::Indexer::addInfo (const \fBIndexerInfo\fP & info)"

.PP
Add the exact path to have the info from\&. 
.PP
\fBParameters\fP
.RS 4
\fIinfo\fP Get the information from the exact path 
.RE
.PP
\fBReturns\fP
.RS 4
\fBIndexerError\fP Return error or success from \fR\fBIndexerError\fP\fP type 
.RE
.PP

.PP
Definition at line \fB198\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
199     {
200         IndexerError error;
201         IndexerInfo totalInfo = info;
202 
203         // Do checks before adding
204         if (totalInfo\&.path\&.empty())
205         {
206             error\&.code = fsi::codes::ERROR_ADDITION_FAIL;
207             error\&.message = "Path is empty";
208             error\&.fatal = false;
209             error\&.raise = false;
210 
211             return error;
212         }
213 
214         if (!fs::exists(totalInfo\&.path))
215         {
216             error\&.code = fsi::codes::ERROR_INVALID_PATH;
217             error\&.message = ciof::format("Unknown path `%1`; No such file or directory exists", totalInfo\&.path);
218             error\&.fatal = true;
219 
220             return error;
221         }
222 
223         
224         // Set path type
225         totalInfo\&.pathType = this\->__getPathType(totalInfo\&.path);
226 
227         // Add final information
228 
229         this\->indexerInfo\&.emplace_back(totalInfo);
230 
231         return error;
232     }
.PP
.fi

.PP
References \fB__getPathType()\fP, \fBfsi::IndexerError::code\fP, \fBfsi::codes::ERROR_ADDITION_FAIL\fP, \fBfsi::codes::ERROR_INVALID_PATH\fP, \fBfsi::IndexerError::fatal\fP, \fBindexerInfo\fP, \fBfsi::IndexerError::message\fP, \fBfsi::IndexerInfo::path\fP, \fBfsi::IndexerInfo::pathType\fP, and \fBfsi::IndexerError::raise\fP\&.
.PP
Referenced by \fB__addExtendedInfoStandard()\fP, and \fB__addExtendedInfoThreaded()\fP\&.
.SS "\fBIndexerInfo\fP fsi::Indexer::findIndex (const std::string & toFind)"

.PP
Find the index from the vector database from the indexer\&. 
.PP
\fBParameters\fP
.RS 4
\fItoFind\fP Search for the path or ID and remove them from the indexer 
.RE
.PP
\fBReturns\fP
.RS 4
\fBIndexerInfo\fP Find the indexed info from the indexer "data base" 
.RE
.PP

.PP
Definition at line \fB234\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
235     {
236         for (const auto &x : this\->indexerInfo)
237         {
238             if (x\&.path == toFind || x\&.id == toFind)
239                 return x;
240         }
241 
242         return { };
243     }
.PP
.fi

.PP
References \fBindexerInfo\fP\&.
.PP
Referenced by \fBmain()\fP, and \fBsearchExactMatching()\fP\&.
.SS "\fButils::TimeUtils_DateTime\fP fsi::Indexer::getFileDTInfo (const std::string & path)"

.PP
Get when the file, dir or symlink was last modified\&. 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP Path to get date time information 
.RE
.PP
\fBReturns\fP
.RS 4
Date time info 
.RE
.PP

.PP
Definition at line \fB275\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
276     {
277         const fs::file_time_type &lastWriteTime = fs::last_write_time(path);
278 
279         return utils::fsClockDataToDT(lastWriteTime);
280     }
.PP
.fi

.PP
References \fBfsi::utils::fsClockDataToDT()\fP\&.
.PP
Referenced by \fBmain()\fP\&.
.SS "std::string fsi::Indexer::getID () const"

.PP
Get this object's ID\&. 
.PP
\fBReturns\fP
.RS 4
Object ID 
.RE
.PP

.PP
Definition at line \fB295\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
296     { return this\->id; }
.PP
.fi

.PP
References \fBid\fP\&.
.SS "std::vector< \fBIndexerInfo\fP > fsi::Indexer::getIndexerInfo () const"

.PP
Return indexer information from this object\&. 
.PP
\fBReturns\fP
.RS 4
Get all the indexed information that was added 
.RE
.PP

.PP
Definition at line \fB282\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
283     { return this\->indexerInfo; }
.PP
.fi

.PP
References \fBindexerInfo\fP\&.
.SS "std::vector< std::string > fsi::Indexer::getIndexPaths () const"

.PP
Get all the indexed paths from the vector indexes\&. 
.PP
\fBReturns\fP
.RS 4
All the indexed paths in a vector 
.RE
.PP

.PP
Definition at line \fB285\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
286     {
287         std::vector<std::string> additions;
288 
289         for (const auto &x : this\->indexerInfo)
290         { additions\&.emplace_back(x\&.path); }
291 
292         return additions;
293     }
.PP
.fi

.PP
References \fBindexerInfo\fP\&.
.SS "\fBIndexerError\fP fsi::Indexer::removeInfo (const std::string & searcher)"

.PP
Remove information from its ID or full path\&. 
.PP
\fBParameters\fP
.RS 4
\fIsearcher\fP Search for the path or ID and remove them from the indexer 
.RE
.PP
\fBReturns\fP
.RS 4
\fBIndexerError\fP Return error or success from \fR\fBIndexerError\fP\fP type 
.RE
.PP

.PP
Definition at line \fB245\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
246     {
247         IndexerError error;
248 
249         // Do checks
250 
251         if (searcher\&.empty())
252         {
253             error\&.code = fsi::codes::ERROR_EMPTY_VALUE;
254             error\&.message = "Empty value to remove from the Indexer Information list";
255             error\&.fatal = false;
256             error\&.raise = false;
257 
258             return error;
259         }
260 
261         // Erase the found object (IndexerInfo) value by ID or Path
262         this\->indexerInfo\&.erase(
263                 std::remove_if(
264                     this\->indexerInfo\&.begin(),
265                     this\->indexerInfo\&.end(),
266                     [&](const IndexerInfo &info) {
267                         return (info\&.id == searcher || info\&.path == searcher);
268                     }),
269                 this\->indexerInfo\&.end()
270         );
271 
272         return error;
273     }
.PP
.fi

.PP
References \fBfsi::IndexerError::code\fP, \fBfsi::codes::ERROR_EMPTY_VALUE\fP, \fBfsi::IndexerError::fatal\fP, \fBindexerInfo\fP, \fBfsi::IndexerError::message\fP, and \fBfsi::IndexerError::raise\fP\&.
.SS "std::string fsi::Indexer::searchExactMatching (const std::string & find)"

.PP
Search for an exact matching path or ID;\&. 
.PP
\fBParameters\fP
.RS 4
\fIfind\fP Get the ID or path to find 
.RE
.PP
\fBReturns\fP
.RS 4
The first match found 
.RE
.PP

.PP
Definition at line \fB183\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
184     {
185         if (find\&.empty())
186             return "";
187 
188         return this\->findIndex(find)\&.path;
189     }
.PP
.fi

.PP
References \fBfindIndex()\fP, and \fBfsi::IndexerInfo::path\fP\&.
.SS "std::vector< std::string > fsi::Indexer::searchMatching (const std::string & path)"

.PP
Either use threaded or unthreaded search matching\&. 
.IP "\(bu" 2
Use \fR\fBIndexer::__searchMatchingThreaded()\fP\fP or \fR\fBIndexer::__searchMatchingStandard()\fP\fP 
.PP
\fBParameters\fP
.RS 4
\fIpath\fP Path to read the data to search 
.RE
.PP
\fBReturns\fP
.RS 4
All the data found in a vector of strings 
.RE
.PP

.PP

.PP
Definition at line \fB191\fP of file \fBFSI_Indexer\&.cpp\fP\&.
.nf
192     {
193         if (this\->threadsImpl) return this\->__searchMatchingThreaded(find);
194 
195         return this\->__searchMatchingStandard(find);
196     }
.PP
.fi

.PP
References \fB__searchMatchingStandard()\fP, \fB__searchMatchingThreaded()\fP, and \fBthreadsImpl\fP\&.
.PP
Referenced by \fBmain()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "std::string fsi::Indexer::id\fR [private]\fP"

.PP
Definition at line \fB63\fP of file \fBFSI_Indexer\&.hpp\fP\&.
.PP
Referenced by \fBIndexer()\fP, and \fBgetID()\fP\&.
.SS "std::vector<\fBIndexerInfo\fP> fsi::Indexer::indexerInfo\fR [private]\fP"

.PP
Definition at line \fB65\fP of file \fBFSI_Indexer\&.hpp\fP\&.
.PP
Referenced by \fB__addExtendedInfoStandard()\fP, \fB__addExtendedInfoThreaded()\fP, \fB__searchMatchingStandard()\fP, \fB__searchMatchingThreaded()\fP, \fBaddInfo()\fP, \fBfindIndex()\fP, \fBgetIndexerInfo()\fP, \fBgetIndexPaths()\fP, and \fBremoveInfo()\fP\&.
.SS "bool fsi::Indexer::threadsImpl\fR [private]\fP"

.PP
Definition at line \fB67\fP of file \fBFSI_Indexer\&.hpp\fP\&.
.PP
Referenced by \fBIndexer()\fP, \fBaddExtendedInfo()\fP, and \fBsearchMatching()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for FileSystemIndexer from the source code\&.
