.TH "argx::Argx" 3 "Version 1.2.0-beta" "Argx" \" -*- nroff -*-
.ad l
.nh
.SH NAME
argx::Argx
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <Argx\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBArgx\fP ()"
.br
.ti -1c
.RI "\fBArgx\fP (const std::string &\fBid\fP, int argc, char *argv[])"
.br
.RI "Create \fBArgx\fP with the specific \fRid\fP, \fRargc\fP and \fRargv\fP "
.ti -1c
.RI "\fB~Argx\fP ()"
.br
.RI "Deconstruct allocated objects\&. "
.ti -1c
.RI "void \fBadd\fP (\fBARGXOptions\fP option) const"
.br
.RI "Add param options\&. "
.ti -1c
.RI "bool \fBcompareArgs\fP (std::vector< \fBARGXOptions\fP > \fBoptions\fP, std::vector< std::string > argv)"
.br
.RI "Compare if \fRoptions\fP contains the required \fRid\fP, if the ID does not exist, return false\&. "
.ti -1c
.RI "std::string \fBcreateDocs\fP (\fBARGXStyle\fP style, const std::string &title, const std::string &mainInfo)"
.br
.RI "Create documentation for the parameters with the specific style, title and main information\&. "
.ti -1c
.RI "int \fBfindParam\fP (const std::string &\fBid\fP)"
.br
.RI "Find parameter and sub-parameter index\&. "
.ti -1c
.RI "int \fBgetArgc\fP () const"
.br
.RI "Get the main options from the \fRmain()\fP function as argc\&. "
.ti -1c
.RI "int \fBgetArgIDPos\fP (const std::string &arg)"
.br
.RI "Get argument using ID\&. "
.ti -1c
.RI "int \fBgetArgPos\fP (const std::string &arg)"
.br
.RI "Get argument position with specified \fRarg\fP "
.ti -1c
.RI "std::string \fBgetID\fP () const"
.br
.RI "Get \fBArgx\fP ID\&. "
.ti -1c
.RI "std::vector< std::string > \fBgetMainArgs\fP () const"
.br
.RI "Get main arguments from \fRmain()\fP function \fRargv\fP "
.ti -1c
.RI "\fBARGXOptions\fP \fBgetOption\fP (const std::string &\fBid\fP)"
.br
.RI "Get Options from specified ID\&. "
.ti -1c
.RI "std::vector< \fBARGXOptions\fP > \fBgetOptions\fP () const"
.br
.RI "Get main set options as \fBARGXOptions\fP\&. "
.ti -1c
.RI "\fBARGXParam\fP \fBgetParam\fP (const std::string &\fBid\fP)"
.br
.RI "Get the param from \fRid\fP "
.ti -1c
.RI "bool \fBgetSubParam\fP (const \fBargx::ARGXParam\fP &param, const std::string &\fBid\fP)"
.br
.RI "Get the sub-param from \fRid\fP "
.ti -1c
.RI "std::vector< std::string > \fBgetSubValue\fP (const std::string &\fBid\fP)"
.br
.RI "Get sub-parameter values, starting from the first value found until the first found value that corresponds to a registered parameter\&. "
.ti -1c
.RI "int \fBgetWrongArgs\fP (const std::vector< std::string > &argv)"
.br
.RI "Get the incorrect arguments and sub-arguments that were not registered\&. "
.ti -1c
.RI "bool \fBhasTag\fP (const std::string &\fBid\fP, const std::string &tag)"
.br
.RI "Check if the \fRtag\fP exists in option with ID of \fRid\fP "
.ti -1c
.RI "bool \fBparamExists\fP (const std::string &\fBid\fP)"
.br
.RI "Get if param exists in the param options\&. "
.ti -1c
.RI "std::string \fBparamToID\fP (const std::string &param)"
.br
.RI "Normal parameter or sub-paramter to its corresponding ID\&. "
.ti -1c
.RI "bool \fBsubParamExists\fP (const std::string &\fBid\fP)"
.br
.RI "Get if sub-param exists in the param options\&. "
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::string \fBid\fP"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static unsigned int \fBmainArgc\fP"
.br
.ti -1c
.RI "static std::vector< std::string > * \fBmainArgs\fP = nullptr"
.br
.ti -1c
.RI "static std::vector< \fBARGXOptions\fP > \fBoptions\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB17\fP of file \fBArgx\&.hpp\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "argx::Argx::Argx (const std::string & id, int argc, char * argv[])"

.PP
Create \fBArgx\fP with the specific \fRid\fP, \fRargc\fP and \fRargv\fP 
.PP
\fBParameters\fP
.RS 4
\fIid\fP Set the ID of the \fBArgx\fP 
.br
\fIargc\fP Set the \fRargc\fP of the \fRmain()\fP function 
.br
\fIargv\fP Set the \fRargv\fP of the \fRmain()\fP function 
.RE
.PP

.PP
Definition at line \fB34\fP of file \fBArgx\&.cpp\fP\&.
.nf
35         : id(id)
36     {
37         this\->mainArgs = new std::vector<std::string>(argv, argv + argc);
38         this\->mainArgc = argc;
39     }
.PP
.fi

.PP
References \fBArgx()\fP, \fBid\fP, \fBmainArgc\fP, and \fBmainArgs\fP\&.
.PP
Referenced by \fBArgx()\fP\&.
.SS "argx::Argx::Argx ()"

.PP
Definition at line \fB42\fP of file \fBArgx\&.cpp\fP\&.
.nf
43     { }
.PP
.fi

.SS "argx::Argx::~Argx ()"

.PP
Deconstruct allocated objects\&. 
.PP
Definition at line \fB45\fP of file \fBArgx\&.cpp\fP\&.
.nf
46     {
47         delete this\->mainArgs; this\->mainArgs = nullptr;
48     }
.PP
.fi

.PP
References \fBmainArgs\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "void argx::Argx::add (\fBARGXOptions\fP option) const"

.PP
Add param options\&. 
.PP
\fBParameters\fP
.RS 4
\fIoption\fP Add the option to the main params 
.RE
.PP

.PP
Definition at line \fB90\fP of file \fBArgx\&.cpp\fP\&.
.nf
91     { this\->options\&.emplace_back(option); }
.PP
.fi

.PP
References \fBoptions\fP\&.
.SS "bool argx::Argx::compareArgs (std::vector< \fBARGXOptions\fP > options, std::vector< std::string > argv)"

.PP
Compare if \fRoptions\fP contains the required \fRid\fP, if the ID does not exist, return false\&. 
.PP
\fBParameters\fP
.RS 4
\fIoptions\fP Return \fBARGXOptions\fP vector 
.br
\fIid\fP ID to find 
.RE
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP

.PP
Definition at line \fB415\fP of file \fBArgx\&.cpp\fP\&.
.nf
416     {
417         for (size_t i = 1 ; i < argv\&.size(); ++i)
418         {
419             const std::string &arg = argv[i];
420 
421             bool found = false;
422             bool hasSubParams = false;
423             bool hasAnySubParams = false;
424 
425             ARGXOptions matchedOption;
426 
427             // Find the matching option
428             for (const auto &option : options)
429             {
430                 if (option\&.sparam == arg || option\&.param == arg)
431                 {
432                     found = true;
433                     hasSubParams = option\&.hasSubParams;
434                     hasAnySubParams = option\&.hasAnySubParams;
435                     matchedOption = option;
436 
437                     break;
438                 }
439             }
440 
441             if (!found) return false;
442 
443             if (hasSubParams || hasAnySubParams)
444             {
445                 // Check if there's a next argument
446                 if (i + 1 < argv\&.size())
447                 {
448                     const std::string &nextArg = argv[i + 1];
449 
450                     // Check if next argument is a sub\-parameter
451                     bool isSubParam = false;
452 
453                     if (!nextArg\&.empty() && nextArg[0] != '\-')
454                     {
455                         // Validate if it's a valid sub\-parameter
456                         for (const auto &subOption : matchedOption\&.subParams)
457                         {
458                             if (subOption\&.param == nextArg || subOption\&.sparam == nextArg)
459                             {
460                                 isSubParam = true;
461 
462                                 break;
463                             }
464                         }
465 
466                         if (isSubParam) ++i; // Get the sub\-parameter
467                         else if (hasSubParams || hasAnySubParams) return false;
468                     }
469 
470                     else if (hasSubParams || hasAnySubParams) return false;
471                 }
472             }
473         }
474 
475         return true;
476     }
.PP
.fi

.PP
References \fBoptions\fP, and \fBargx::ARGXOptions::subParams\fP\&.
.SS "std::string argx::Argx::createDocs (\fBARGXStyle\fP style, const std::string & title, const std::string & mainInfo)"

.PP
Create documentation for the parameters with the specific style, title and main information\&. 
.PP
\fBParameters\fP
.RS 4
\fIstyle\fP Set the style using \fBARGXStyle\fP 
.br
\fItitle\fP Title for docs 
.br
\fIMain\fP information 
.RE
.PP
\fBReturns\fP
.RS 4
std::string Documentation as a string 
.RE
.PP

.PP
Definition at line \fB290\fP of file \fBArgx\&.cpp\fP\&.
.nf
291     {
292         std::string contentStr;
293 
294         if (style == ARGXStyle::Professional)
295         {
296             for (const auto &x : this\->options)
297             {
298                 // Main option header line
299                 contentStr += "ID: " + x\&.id + "\\n";
300                 contentStr += "[ " + x\&.sparam + " | " + x\&.param;
301 
302                 if (x\&.hasSubParams && !x\&.subParams\&.empty())
303                 {
304                     contentStr += " [ ";
305 
306                     for (size_t i = 0; i < x\&.subParams\&.size(); ++i)
307                     {
308                         const auto &sub = x\&.subParams[i];
309 
310                         contentStr += sub\&.param;
311 
312                         if (i < x\&.subParams\&.size() \- 1) contentStr += " | ";
313                         else if (i <= x\&.subParams\&.size()) contentStr += ' ';
314                     }
315 
316                     contentStr += "] ] ";
317                 }
318 
319                 else contentStr += " ] ";
320 
321                 contentStr += x\&.info + "\\n";
322 
323                 // Print all sub\-options with sparam and param, aligned with ideographic spaces if there are
324                 if (x\&.hasSubParams && !x\&.subParams\&.empty())
325                 {
326                     for (const auto &sub : x\&.subParams)
327                     {
328                         // Create ideographic spaces matching the length of main param for alignment
329                         std::wstring wideSpaces(x\&.param\&.size(), L'\\u3000');
330                         std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
331                         std::string spacing = converter\&.to_bytes(wideSpaces);
332 
333                         contentStr += spacing + "  [ " + sub\&.sparam + " | " + sub\&.param + " ] " + sub\&.info + "\\n";
334                     }
335                 }
336             }
337         }
338 
339         else if (style == ARGXStyle::Simple)
340         {
341             for (const auto &x : this\->options)
342             {
343                 contentStr += x\&.sparam + ", " + x\&.param + " \- " + x\&.info + "\\n";
344 
345                 if (x\&.hasSubParams && !x\&.subParams\&.empty())
346                 {
347                     for (const auto &sub : x\&.subParams)
348                     {
349                         contentStr += "  " + sub\&.sparam + ", " + sub\&.param + " \- " + sub\&.info + "\\n";
350                     }
351                 }
352             }
353         } // ARGXStyle
354 
355         return title + "\\n" + mainInfo + "\\n" + contentStr;
356     }
.PP
.fi

.PP
References \fBoptions\fP, \fBargx::Professional\fP, and \fBargx::Simple\fP\&.
.SS "int argx::Argx::findParam (const std::string & id)"

.PP
Find parameter and sub-parameter index\&. 
.PP
\fBParameters\fP
.RS 4
\fIid\fP ID to find 
.RE
.PP
\fBReturns\fP
.RS 4
int Index 
.RE
.PP

.PP
Definition at line \fB93\fP of file \fBArgx\&.cpp\fP\&.
.nf
94     {
95         // First check if it's a main parameter
96         for (size_t i = 0; i < this\->options\&.size(); i++)
97         {
98             if (this\->options[i]\&.id == id)
99             {
100                 // Check if this main parameter exists in arguments
101                 for (const std::string &arg : *this\->mainArgs)
102                 {
103                     if (arg == this\->options[i]\&.param || arg == this\->options[i]\&.sparam)
104                     {
105                         return static_cast<int>(i);
106                     }
107                 }
108             }
109         }
110 
111         // Then look for sub\-parameters
112         for (const auto &opt : this\->options)
113         {
114             // Check if the parent option exists in the arguments
115             bool parentExists = false;
116 
117             for (const std::string &arg : *this\->mainArgs)
118             {
119                 if (arg == opt\&.param || arg == opt\&.sparam)
120                 {
121                     parentExists = true;
122                     break;
123                 }
124             }
125 
126             if (parentExists)
127             {
128                 // Find the index of the requested sub\-parameter
129                 for (size_t i = 0; i < opt\&.subParams\&.size(); i++)
130                 {
131                     if (opt\&.subParams[i]\&.id == id) return static_cast<int>(i);
132                 }
133             }
134         }
135 
136         return \-1; // Not found
137     }
.PP
.fi

.PP
References \fBmainArgs\fP, and \fBoptions\fP\&.
.PP
Referenced by \fBgetSubParam()\fP, \fBhasTag()\fP, and \fBparamExists()\fP\&.
.SS "int argx::Argx::getArgc () const"

.PP
Get the main options from the \fRmain()\fP function as argc\&. 
.PP
\fBReturns\fP
.RS 4
int Number of params including the executable param 
.RE
.PP

.PP
Definition at line \fB539\fP of file \fBArgx\&.cpp\fP\&.
.nf
540     { return this\->mainArgc; }
.PP
.fi

.PP
References \fBmainArgc\fP\&.
.SS "int argx::Argx::getArgIDPos (const std::string & arg)"

.PP
Get argument using ID\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP Argument to find 
.RE
.PP
\fBReturns\fP
.RS 4
int Argument position 
.RE
.PP

.PP
Definition at line \fB50\fP of file \fBArgx\&.cpp\fP\&.
.nf
51     {
52         ARGXOptions option = this\->getOption(arg);
53         
54         int argPos = this\->getArgPos(option\&.param);
55         int shortArgPos = this\->getArgPos(option\&.sparam);
56 
57         if (argPos >= 0) return argPos;
58         if (shortArgPos >= 0) return shortArgPos;
59 
60         return \-1;
61     }
.PP
.fi

.PP
References \fBgetArgPos()\fP, \fBgetOption()\fP, \fBargx::ARGXOptions::param\fP, and \fBargx::ARGXOptions::sparam\fP\&.
.SS "int argx::Argx::getArgPos (const std::string & arg)"

.PP
Get argument position with specified \fRarg\fP 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP Find argument 
.RE
.PP
\fBReturns\fP
.RS 4
int Return position of found \fRarg\fP from the options 
.RE
.PP

.PP
Definition at line \fB76\fP of file \fBArgx\&.cpp\fP\&.
.nf
77     {
78         if (!this\->mainArgs)
79             return \-2;
80 
81         for (size_t i = 0; i < this\->mainArgs\->size(); ++i)
82         {
83             if (this\->mainArgs\->at(i) == arg)
84                 return i;
85         }
86 
87         return \-1;
88     }
.PP
.fi

.PP
References \fBmainArgs\fP\&.
.PP
Referenced by \fBgetArgIDPos()\fP, and \fBgetSubValue()\fP\&.
.SS "std::string argx::Argx::getID () const"

.PP
Get \fBArgx\fP ID\&. 
.PP
\fBReturns\fP
.RS 4
std::string \fBArgx\fP ID 
.RE
.PP

.PP
Definition at line \fB545\fP of file \fBArgx\&.cpp\fP\&.
.nf
546     { return this\->id; }
.PP
.fi

.SS "std::vector< std::string > argx::Argx::getMainArgs () const"

.PP
Get main arguments from \fRmain()\fP function \fRargv\fP 
.PP
\fBReturns\fP
.RS 4
std::vector<std::string> Vector of strings for main arguments from \fRargv\fP 
.RE
.PP

.PP
Definition at line \fB536\fP of file \fBArgx\&.cpp\fP\&.
.nf
537     { return *this\->mainArgs; }
.PP
.fi

.PP
References \fBmainArgs\fP\&.
.PP
Referenced by \fBgetSubValue()\fP\&.
.SS "\fBARGXOptions\fP argx::Argx::getOption (const std::string & id)"

.PP
Get Options from specified ID\&. 
.PP
\fBParameters\fP
.RS 4
\fIid\fP ID to find 
.br
\fI\fBARGXOptions\fP\fP Option information 
.RE
.PP

.PP
Definition at line \fB478\fP of file \fBArgx\&.cpp\fP\&.
.nf
479     {
480         for (const auto &x : this\->options)
481             if (x\&.id == id) return x;
482 
483         return {};
484     }
.PP
.fi

.PP
References \fBoptions\fP\&.
.PP
Referenced by \fBgetArgIDPos()\fP, and \fBgetSubValue()\fP\&.
.SS "std::vector< \fBARGXOptions\fP > argx::Argx::getOptions () const"

.PP
Get main set options as \fBARGXOptions\fP\&. 
.PP
\fBReturns\fP
.RS 4
std::vector<ARGXOptions> Options to return 
.RE
.PP

.PP
Definition at line \fB542\fP of file \fBArgx\&.cpp\fP\&.
.nf
543     { return this\->options; }
.PP
.fi

.PP
References \fBoptions\fP\&.
.SS "\fBARGXParam\fP argx::Argx::getParam (const std::string & id)"

.PP
Get the param from \fRid\fP 
.PP
\fBParameters\fP
.RS 4
\fIid\fP The ID to get 
.RE
.PP
\fBReturns\fP
.RS 4
\fBARGXParam\fP Returnted parameter to get 
.RE
.PP

.PP
Definition at line \fB168\fP of file \fBArgx\&.cpp\fP\&.
.nf
169     {
170         if (this\->mainArgc <= 1) return {};
171 
172         ARGXParam result;
173 
174         // First, check if this is a top\-level option
175         for (const auto &opt : this\->options)
176         {
177             if (opt\&.id == id)
178             {
179                 // Find the position of the main option in arguments
180                 int mainOptionPos = \-1;
181 
182                 for (size_t i = 0; i < this\->mainArgs\->size(); ++i)
183                 {
184                     if ((*this\->mainArgs)[i] == opt\&.param || (*this\->mainArgs)[i] == opt\&.sparam)
185                     {
186                         result\&.exists = true;
187                         mainOptionPos = i;
188                         break;
189                     }
190                 }
191 
192                 if (result\&.exists)
193                 {
194                     if (opt\&.hasSubParams || opt\&.hasAnySubParams)
195                     {
196                         // Check each sub\-parameter
197                         for (const auto &sub : opt\&.subParams)
198                         {
199                             bool subMatched = false;
200 
201                             // Look for sub\-parameters after the main option
202                             for (size_t i = mainOptionPos + 1; i < this\->mainArgs\->size(); ++i)
203                             {
204                                 if ((*this\->mainArgs)[i] == sub\&.param || (*this\->mainArgs)[i] == sub\&.sparam)
205                                 {
206                                     subMatched = true;
207                                     break;
208                                 }
209                             }
210 
211                             result\&.subExists\&.push_back(subMatched);
212                         }
213                     }
214 
215                     return result;
216                 }
217             }
218         }
219 
220         // If not found as top\-level, check if it's a sub\-parameter
221         for (const auto &opt : this\->options)
222         {
223             // Find if the parent option exists and get its position
224             size_t parentPos = \-1;
225 
226             for (size_t i = 0; i < this\->mainArgs\->size(); ++i)
227             {
228                 if ((*this\->mainArgs)[i] == opt\&.param || (*this\->mainArgs)[i] == opt\&.sparam)
229                 {
230                     parentPos = i;
231                     break;
232                 }
233             }
234 
235             if (parentPos > \-1 && (opt\&.hasSubParams || opt\&.hasAnySubParams))
236             {
237                 // Check if the requested sub\-parameter exists after the parent
238                 for (const auto &sub : opt\&.subParams)
239                 {
240                     if (sub\&.id == id)
241                     {
242                         for (size_t i = parentPos + 1 ; i < this\->mainArgs\->size(); ++i)
243                         {
244                             if ((*this\->mainArgs)[i] == sub\&.param || (*this\->mainArgs)[i] == sub\&.sparam)
245                             {
246                                 result\&.exists = true;
247                                 break;
248                             }
249                         }
250 
251                         if (!result\&.exists && parentPos + 1 < this\->mainArgs\->size())
252                         {
253                             std::string nextArg = (*this\->mainArgs)[parentPos + 1];
254 
255                             if (nextArg == sub\&.param || nextArg == sub\&.sparam) result\&.exists = true;
256                         }
257 
258                         // Handle any sub\-sub\-parameters if they exist
259                         if (result\&.exists && (sub\&.hasSubParams || sub\&.hasAnySubParams))
260                         {
261                             for (const auto &subsub : sub\&.subParams)
262                             {
263                                 bool subsubMatched = false;
264 
265                                 for (size_t i = 0; i < this\->mainArgs\->size(); ++i)
266                                 {
267                                     if ((*this\->mainArgs)[i] == subsub\&.param || (*this\->mainArgs)[i] == subsub\&.sparam)
268                                     {
269                                         subsubMatched = true;
270                                         break;
271                                     }
272                                 }
273 
274                                 result\&.subExists\&.push_back(subsubMatched);
275                             }
276                         }
277 
278                         return result;
279                     }
280                 }
281             }
282         }
283 
284         return result;
285     }
.PP
.fi

.PP
References \fBargx::ARGXParam::exists\fP, \fBmainArgc\fP, \fBmainArgs\fP, \fBoptions\fP, and \fBargx::ARGXParam::subExists\fP\&.
.SS "bool argx::Argx::getSubParam (const \fBargx::ARGXParam\fP & param, const std::string & id)"

.PP
Get the sub-param from \fRid\fP 
.PP
\fBParameters\fP
.RS 4
\fIparam\fP Original param 
.br
\fIid\fP The ID to get 
.RE
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP

.PP
Definition at line \fB287\fP of file \fBArgx\&.cpp\fP\&.
.nf
288     { return this\->paramExists(id) && param\&.subExists[this\->findParam(id)]; }
.PP
.fi

.PP
References \fBfindParam()\fP, \fBparamExists()\fP, and \fBargx::ARGXParam::subExists\fP\&.
.SS "std::vector< std::string > argx::Argx::getSubValue (const std::string & id)"

.PP
Get sub-parameter values, starting from the first value found until the first found value that corresponds to a registered parameter\&. 
.PP
\fBParameters\fP
.RS 4
\fIid\fP ID to find to get sub-value 
.RE
.PP
\fBReturns\fP
.RS 4
std::vector<std::string> Values found from first to last 
.RE
.PP

.PP
Definition at line \fB486\fP of file \fBArgx\&.cpp\fP\&.
.nf
487     {
488         // Use `Argx::getArgPos()` function for sub\-params
489         size_t idPos = this\->getArgPos(id) + 1;
490 
491         if (idPos < 0 || idPos == std::string::npos)
492             return {this\->getOption(id)\&.defaultValue};
493 
494         std::vector<std::string> values;
495 
496         for (size_t i = idPos ; i < this\->getMainArgs()\&.size() ; i++)
497         {
498             // End of the sub\-parameter finding
499             // Assume the search is done due to an existsing sub\-param
500             if (i != idPos && this\->subParamExists(this\->getMainArgs()[i]))
501                 break;
502 
503             values\&.emplace_back(this\->getMainArgs()[i]);
504         }
505 
506         std::string defaultValue;
507 
508         {
509             bool breakOut = false;
510 
511             for (size_t i = 0; i < this\->mainArgs\->size(); ++i)
512             {
513                 for (size_t j = 0 ; j < this\->options\&.size() ; ++j)
514                 {
515                     if (this\->options[i]\&.subParams[j]\&.id == id)
516                     {
517                         defaultValue = this\->options[i]\&.subParams[j]\&.defaultValue;
518 
519 
520                         breakOut = true;
521 
522                         break;
523                     }
524                 }
525 
526                 if (breakOut) break;
527             }
528         }
529 
530         if (values\&.empty())
531             values\&.emplace_back(defaultValue);
532 
533         return values;
534     }
.PP
.fi

.PP
References \fBargx::ARGXOptions::defaultValue\fP, \fBgetArgPos()\fP, \fBgetMainArgs()\fP, \fBgetOption()\fP, \fBmainArgs\fP, \fBoptions\fP, and \fBsubParamExists()\fP\&.
.SS "int argx::Argx::getWrongArgs (const std::vector< std::string > & argv)"

.PP
Get the incorrect arguments and sub-arguments that were not registered\&. 
.PP
\fBParameters\fP
.RS 4
\fIargv\fP Main arguments from argv 
.RE
.PP
\fBReturns\fP
.RS 4
int Argument position 
.RE
.PP

.PP
Definition at line \fB358\fP of file \fBArgx\&.cpp\fP\&.
.nf
359     {
360         size_t pos = 1; // Skip program name
361 
362         while (pos < argv\&.size())
363         {
364             const auto &arg = argv[pos];
365             bool recognized = false;
366 
367             for (const auto &opt : this\->options)
368             {
369                 if (arg == opt\&.param || arg == opt\&.sparam)
370                 {
371                     recognized = true;
372 
373                     // Skip all subparams if they exist
374                     if (opt\&.hasSubParams || opt\&.hasAnySubParams)
375                     {
376                         // Count subparams that actually exist in argv
377                         for (size_t sub = 1; sub + pos < argv\&.size(); ++sub)
378                         {
379                             const std::string &nextArg = argv[pos + sub];
380 
381                             // If nextArg matches one of the defined subParams, skip it
382                             bool isSub = false;
383 
384                             for (const auto &subOpt : opt\&.subParams)
385                             {
386                                 if (nextArg == subOpt\&.param || nextArg == subOpt\&.sparam)
387                                 {
388                                     isSub = true;
389 
390                                     break;
391                                 }
392                             }
393 
394                             if (!isSub) break;
395 
396                             ++pos; // Skip this subparam
397                         }
398                     }
399 
400                     break; // stop checking options
401                 }
402             }
403 
404             if (!recognized)
405             {
406                 return (int)pos;
407             }
408 
409             ++pos;
410         }
411 
412         return \-1;
413     }
.PP
.fi

.PP
References \fBoptions\fP\&.
.SS "bool argx::Argx::hasTag (const std::string & id, const std::string & tag)"

.PP
Check if the \fRtag\fP exists in option with ID of \fRid\fP 
.PP
\fBParameters\fP
.RS 4
\fIid\fP ID from option 
.br
\fItag\fP Tag to find 
.RE
.PP
\fBReturns\fP
.RS 4
bool Return false if there is no match, else, return true 
.RE
.PP

.PP
Definition at line \fB156\fP of file \fBArgx\&.cpp\fP\&.
.nf
157     {
158         int paramID = this\->findParam(id);
159 
160         if (paramID < 0) return false;
161         
162         // Validate if tag from options is equal to this tag from function param
163         if (this\->options[paramID]\&.tag == tag) return true;
164 
165         return false;
166     }
.PP
.fi

.PP
References \fBfindParam()\fP, and \fBoptions\fP\&.
.SS "bool argx::Argx::paramExists (const std::string & id)"

.PP
Get if param exists in the param options\&. 
.PP
\fBParameters\fP
.RS 4
\fIid\fP ID to get 
.RE
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP

.PP
Definition at line \fB139\fP of file \fBArgx\&.cpp\fP\&.
.nf
140     {
141         if (this\->findParam(id) >= 0) return true;
142 
143         return false;
144     }
.PP
.fi

.PP
References \fBfindParam()\fP\&.
.PP
Referenced by \fBgetSubParam()\fP\&.
.SS "std::string argx::Argx::paramToID (const std::string & param)"

.PP
Normal parameter or sub-paramter to its corresponding ID\&. 
.PP
\fBParameters\fP
.RS 4
\fIparam\fP Parameter value or name 
.RE
.PP
\fBReturns\fP
.RS 4
std::string ID of the param or sub-param 
.RE
.PP

.PP
Definition at line \fB63\fP of file \fBArgx\&.cpp\fP\&.
.nf
64     {
65         std::string id;
66 
67         for (const auto &option : this\->options)
68         {
69             if (option\&.param == param || option\&.sparam == param)
70                 return option\&.id;
71         }
72 
73         return id;
74     }
.PP
.fi

.PP
References \fBid\fP, and \fBoptions\fP\&.
.SS "bool argx::Argx::subParamExists (const std::string & id)"

.PP
Get if sub-param exists in the param options\&. 
.PP
\fBParameters\fP
.RS 4
\fIid\fP ID to get 
.RE
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP

.PP
Definition at line \fB146\fP of file \fBArgx\&.cpp\fP\&.
.nf
147     {
148         for (const auto &p : this\->options)
149         {
150             if (p\&.sparam == id) return true;
151         }
152         
153         return false;
154     }
.PP
.fi

.PP
References \fBoptions\fP\&.
.PP
Referenced by \fBgetSubValue()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "std::string argx::Argx::id\fR [private]\fP"

.PP
Definition at line \fB20\fP of file \fBArgx\&.hpp\fP\&.
.PP
Referenced by \fBArgx()\fP, and \fBparamToID()\fP\&.
.SS "unsigned int argx::Argx::mainArgc\fR [static]\fP, \fR [private]\fP"

.PP
Definition at line \fB25\fP of file \fBArgx\&.hpp\fP\&.
.PP
Referenced by \fBArgx()\fP, \fBgetArgc()\fP, and \fBgetParam()\fP\&.
.SS "std::vector< std::string > * argx::Argx::mainArgs = nullptr\fR [static]\fP, \fR [private]\fP"

.PP
Definition at line \fB23\fP of file \fBArgx\&.hpp\fP\&.
.PP
Referenced by \fBArgx()\fP, \fB~Argx()\fP, \fBfindParam()\fP, \fBgetArgPos()\fP, \fBgetMainArgs()\fP, \fBgetParam()\fP, and \fBgetSubValue()\fP\&.
.SS "std::vector< \fBARGXOptions\fP > argx::Argx::options\fR [static]\fP, \fR [private]\fP"

.PP
Definition at line \fB22\fP of file \fBArgx\&.hpp\fP\&.
.PP
Referenced by \fBadd()\fP, \fBcompareArgs()\fP, \fBcreateDocs()\fP, \fBfindParam()\fP, \fBgetOption()\fP, \fBgetOptions()\fP, \fBgetParam()\fP, \fBgetSubValue()\fP, \fBgetWrongArgs()\fP, \fBhasTag()\fP, \fBparamToID()\fP, and \fBsubParamExists()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Argx from the source code\&.
