.TH "argx::Argx" 3 "Version 1.2.2-build" "Argx" \" -*- nroff -*-
.ad l
.nh
.SH NAME
argx::Argx
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <Argx\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBArgx\fP ()"
.br
.ti -1c
.RI "\fBArgx\fP (const std::string &\fBid\fP, int argc, char *argv[])"
.br
.RI "Create \fBArgx\fP with the specific \fRid\fP, \fRargc\fP and \fRargv\fP "
.ti -1c
.RI "\fB~Argx\fP ()"
.br
.RI "Deconstruct allocated objects\&. "
.ti -1c
.RI "void \fBadd\fP (\fBARGXOptions\fP option) const"
.br
.RI "Add param options\&. "
.ti -1c
.RI "bool \fBcompareArgs\fP (std::vector< \fBARGXOptions\fP > \fBoptions\fP, std::vector< std::string > argv)"
.br
.RI "Compare if \fRoptions\fP contains the required \fRid\fP, if the ID does not exist, return false\&. "
.ti -1c
.RI "std::string \fBcreateDocs\fP (\fBARGXStyle\fP style, const std::string &title, const std::string &mainInfo)"
.br
.RI "Create documentation for the parameters with the specific style, title and main information\&. "
.ti -1c
.RI "int \fBfindParam\fP (const std::string &\fBid\fP)"
.br
.RI "Find parameter and sub-parameter index\&. "
.ti -1c
.RI "int \fBgetArgc\fP () const"
.br
.RI "Get the main options from the \fRmain()\fP function as argc\&. "
.ti -1c
.RI "int \fBgetArgIDPos\fP (const std::string &arg)"
.br
.RI "Get argument using ID\&. "
.ti -1c
.RI "int \fBgetArgPos\fP (const std::string &arg)"
.br
.RI "Get argument position with specified \fRarg\fP "
.ti -1c
.RI "std::string \fBgetID\fP () const"
.br
.RI "Get \fBArgx\fP ID\&. "
.ti -1c
.RI "std::vector< std::string > \fBgetMainArgs\fP () const"
.br
.RI "Get main arguments from \fRmain()\fP function \fRargv\fP "
.ti -1c
.RI "\fBARGXOptions\fP \fBgetOption\fP (const std::string &\fBid\fP)"
.br
.RI "Get Options from specified ID\&. "
.ti -1c
.RI "std::vector< \fBARGXOptions\fP > \fBgetOptions\fP () const"
.br
.RI "Get main set options as \fBARGXOptions\fP\&. "
.ti -1c
.RI "\fBARGXParam\fP \fBgetParam\fP (const std::string &\fBid\fP)"
.br
.RI "Get the param from \fRid\fP "
.ti -1c
.RI "bool \fBgetSubParam\fP (const \fBargx::ARGXParam\fP &param, const std::string &\fBid\fP)"
.br
.RI "Get the sub-param from \fRid\fP "
.ti -1c
.RI "std::vector< std::string > \fBgetSubValue\fP (const std::string &\fBid\fP)"
.br
.RI "Get sub-parameter values, starting from the first value found until the first found value that corresponds to a registered parameter\&. "
.ti -1c
.RI "int \fBgetWrongArgs\fP (const std::vector< std::string > &argv)"
.br
.RI "Get the incorrect arguments and sub-arguments that were not registered\&. "
.ti -1c
.RI "bool \fBhasTag\fP (const std::string &\fBid\fP, const std::string &tag)"
.br
.RI "Check if the \fRtag\fP exists in option with ID of \fRid\fP "
.ti -1c
.RI "bool \fBparamExists\fP (const std::string &\fBid\fP)"
.br
.RI "Get if param exists in the param options\&. "
.ti -1c
.RI "std::string \fBparamToID\fP (const std::string &param)"
.br
.RI "Normal parameter or sub-paramter to its corresponding ID\&. "
.ti -1c
.RI "bool \fBsubParamExists\fP (const std::string &\fBid\fP)"
.br
.RI "Get if sub-param exists in the param options\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static int \fBformatWrongArgs\fP (const int &_int)"
.br
.RI "Format to a positive number if number is negative for a correct execution of code\&. "
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "std::string \fBid\fP"
.br
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static unsigned int \fBmainArgc\fP"
.br
.ti -1c
.RI "static std::vector< std::string > * \fBmainArgs\fP = nullptr"
.br
.ti -1c
.RI "static std::vector< \fBARGXOptions\fP > \fBoptions\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB17\fP of file \fBArgx\&.hpp\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "argx::Argx::Argx (const std::string & id, int argc, char * argv[])"

.PP
Create \fBArgx\fP with the specific \fRid\fP, \fRargc\fP and \fRargv\fP 
.PP
\fBParameters\fP
.RS 4
\fIid\fP Set the ID of the \fBArgx\fP 
.br
\fIargc\fP Set the \fRargc\fP of the \fRmain()\fP function 
.br
\fIargv\fP Set the \fRargv\fP of the \fRmain()\fP function 
.RE
.PP

.PP
Definition at line \fB34\fP of file \fBArgx\&.cpp\fP\&.
.nf
35         : id(id)
36     {
37         this\->mainArgs = new std::vector<std::string>(argv, argv + argc);
38         this\->mainArgc = argc;
39 
40         if (!this\->mainArgs)
41             std::cerr << "`Args::mainArgs` is not valid for ID of " + id + " variable is NULL";
42     }
.PP
.fi

.PP
References \fBArgx()\fP, \fBid\fP, \fBmainArgc\fP, and \fBmainArgs\fP\&.
.PP
Referenced by \fBArgx()\fP\&.
.SS "argx::Argx::Argx ()"

.PP
Definition at line \fB45\fP of file \fBArgx\&.cpp\fP\&.
.nf
46     { }
.PP
.fi

.SS "argx::Argx::~Argx ()"

.PP
Deconstruct allocated objects\&. 
.PP
Definition at line \fB48\fP of file \fBArgx\&.cpp\fP\&.
.nf
49     {
50         if (this\->mainArgs) { delete this\->mainArgs; this\->mainArgs = nullptr; }
51     }
.PP
.fi

.PP
References \fBmainArgs\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "void argx::Argx::add (\fBARGXOptions\fP option) const"

.PP
Add param options\&. 
.PP
\fBParameters\fP
.RS 4
\fIoption\fP Add the option to the main params 
.RE
.PP

.PP
Definition at line \fB93\fP of file \fBArgx\&.cpp\fP\&.
.nf
94     { this\->options\&.emplace_back(option); }
.PP
.fi

.PP
References \fBoptions\fP\&.
.SS "bool argx::Argx::compareArgs (std::vector< \fBARGXOptions\fP > options, std::vector< std::string > argv)"

.PP
Compare if \fRoptions\fP contains the required \fRid\fP, if the ID does not exist, return false\&. 
.PP
\fBParameters\fP
.RS 4
\fIoptions\fP Return \fBARGXOptions\fP vector 
.br
\fIid\fP ID to find 
.RE
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP

.PP
Definition at line \fB489\fP of file \fBArgx\&.cpp\fP\&.
.nf
490     {
491         // iterate over argv and skip program name
492         for (size_t i = 1; i < argv\&.size(); ++i)
493         {
494             const std::string &arg = argv[i];
495 
496             // find a matching top\-level option
497             const ARGXOptions *matched = nullptr;
498 
499             for (const auto &opt : options)
500             {
501                 if (opt\&.sparam == arg || opt\&.param == arg)
502                 {
503                     matched = &opt;
504 
505                     break;
506                 }
507             }
508 
509             // No matched top\-level option
510             if (!matched) return false;
511 
512             // if option supports subparams, try to get them
513             if (matched\->hasSubParams || matched\->hasAnySubParams)
514             {
515                 size_t j = i + 1;
516 
517                 while (j < argv\&.size())
518                 {
519                     const std::string &next = argv[j];
520 
521                     // Check the next declared subparam of `matched`
522                     bool isSub = false;
523 
524                     for (const auto &sub : matched\->subParams)
525                     {
526                         if (next == sub\&.param || next == sub\&.sparam)
527                         {
528                             isSub = true;
529 
530                             break;
531                         }
532                     }
533 
534                     // Get it and continue scanning for more subparams
535                     if (isSub)
536                     {
537                         ++j;
538 
539                         continue;
540                     }
541 
542                     // not a subparam then check if it's a known top\-level option
543                     bool isGlobal = false;
544 
545                     for (const auto &g : options)
546                     {
547                         if (next == g\&.param || next == g\&.sparam)
548                         {
549                             isGlobal = true;
550                             break;
551                         }
552                     }
553 
554 
555                     // stop scanning subparams; outer loop will handle this global option
556                     if (isGlobal) break;
557 
558                     // neither a subparam nor a global option to an invalid sequence
559                     return false;
560                 }
561 
562                 // advance outer index to the last consumed token ( j \- 1 )\&.
563                 // outer for\-loop will increment i, so set `i = j \- 1` to continue at j
564                 if (j > i + 1)
565                     i = j \- 1;
566             }
567         }
568 
569         return true;
570     }
.PP
.fi

.PP
References \fBargx::ARGXOptions::hasAnySubParams\fP, \fBargx::ARGXOptions::hasSubParams\fP, \fBoptions\fP, and \fBargx::ARGXOptions::subParams\fP\&.
.SS "std::string argx::Argx::createDocs (\fBARGXStyle\fP style, const std::string & title, const std::string & mainInfo)"

.PP
Create documentation for the parameters with the specific style, title and main information\&. 
.PP
\fBParameters\fP
.RS 4
\fIstyle\fP Set the style using \fBARGXStyle\fP 
.br
\fItitle\fP Title for docs 
.br
\fIMain\fP information 
.RE
.PP
\fBReturns\fP
.RS 4
std::string Documentation as a string 
.RE
.PP

.PP
Definition at line \fB293\fP of file \fBArgx\&.cpp\fP\&.
.nf
294     {
295         std::string contentStr;
296 
297         if (style == ARGXStyle::Professional)
298         {
299             for (const auto &x : this\->options)
300             {
301                 // Main option header line
302                 contentStr += "ID: " + x\&.id + "\\n";
303                 contentStr += "[ " + x\&.sparam + " | " + x\&.param;
304 
305                 if (x\&.hasSubParams && !x\&.subParams\&.empty())
306                 {
307                     contentStr += " [ ";
308 
309                     for (size_t i = 0; i < x\&.subParams\&.size(); ++i)
310                     {
311                         const auto &sub = x\&.subParams[i];
312 
313                         contentStr += sub\&.param;
314 
315                         if (i < x\&.subParams\&.size() \- 1) contentStr += " | ";
316                         else if (i <= x\&.subParams\&.size()) contentStr += ' ';
317                     }
318 
319                     contentStr += "] ] ";
320                 }
321 
322                 else contentStr += " ] ";
323 
324                 contentStr += x\&.info + "\\n";
325 
326                 // Print all sub\-options with sparam and param, aligned with ideographic spaces if there are
327                 if (x\&.hasSubParams && !x\&.subParams\&.empty())
328                 {
329                     for (const auto &sub : x\&.subParams)
330                     {
331                         // Create ideographic spaces matching the length of main param for alignment
332                         std::wstring wideSpaces(x\&.param\&.size(), L'\\u3000');
333                         std::wstring_convert<std::codecvt_utf8<wchar_t>> converter;
334                         std::string spacing = converter\&.to_bytes(wideSpaces);
335 
336                         contentStr += spacing + "  [ " + sub\&.sparam + " | " + sub\&.param + " ] " + sub\&.info + "\\n";
337                     }
338                 }
339             }
340         }
341 
342         else if (style == ARGXStyle::Simple)
343         {
344             for (const auto &x : this\->options)
345             {
346                 contentStr += x\&.sparam + ", " + x\&.param + " \- " + x\&.info + "\\n";
347 
348                 if (x\&.hasSubParams && !x\&.subParams\&.empty())
349                 {
350                     for (const auto &sub : x\&.subParams)
351                     {
352                         contentStr += "  " + sub\&.sparam + ", " + sub\&.param + " \- " + sub\&.info + "\\n";
353                     }
354                 }
355             }
356         } // ARGXStyle
357 
358         return title + "\\n" + mainInfo + "\\n" + contentStr;
359     }
.PP
.fi

.PP
References \fBoptions\fP, \fBargx::Professional\fP, and \fBargx::Simple\fP\&.
.SS "int argx::Argx::findParam (const std::string & id)"

.PP
Find parameter and sub-parameter index\&. 
.PP
\fBParameters\fP
.RS 4
\fIid\fP ID to find 
.RE
.PP
\fBReturns\fP
.RS 4
int Index 
.RE
.PP

.PP
Definition at line \fB96\fP of file \fBArgx\&.cpp\fP\&.
.nf
97     {
98         // First check if it's a main parameter
99         for (size_t i = 0; i < this\->options\&.size(); i++)
100         {
101             if (this\->options[i]\&.id == id)
102             {
103                 // Check if this main parameter exists in arguments
104                 for (const std::string &arg : *this\->mainArgs)
105                 {
106                     if (arg == this\->options[i]\&.param || arg == this\->options[i]\&.sparam)
107                     {
108                         return static_cast<int>(i);
109                     }
110                 }
111             }
112         }
113 
114         // Then look for sub\-parameters
115         for (const auto &opt : this\->options)
116         {
117             // Check if the parent option exists in the arguments
118             bool parentExists = false;
119 
120             for (const std::string &arg : *this\->mainArgs)
121             {
122                 if (arg == opt\&.param || arg == opt\&.sparam)
123                 {
124                     parentExists = true;
125                     break;
126                 }
127             }
128 
129             if (parentExists)
130             {
131                 // Find the index of the requested sub\-parameter
132                 for (size_t i = 0; i < opt\&.subParams\&.size(); i++)
133                 {
134                     if (opt\&.subParams[i]\&.id == id) return static_cast<int>(i);
135                 }
136             }
137         }
138 
139         return \-1; // Not found
140     }
.PP
.fi

.PP
References \fBmainArgs\fP, and \fBoptions\fP\&.
.PP
Referenced by \fBgetSubParam()\fP, \fBhasTag()\fP, and \fBparamExists()\fP\&.
.SS "int argx::Argx::formatWrongArgs (const int & _int)\fR [static]\fP"

.PP
Format to a positive number if number is negative for a correct execution of code\&. 
.PP
\fBParameters\fP
.RS 4
\fI_int\fP Number to convert 
.RE
.PP
\fBReturns\fP
.RS 4
int Positive value number 
.RE
.PP

.PP
Definition at line \fB482\fP of file \fBArgx\&.cpp\fP\&.
.nf
483     {
484         if (_int < 0) return \-_int; // Convert to unsigned SAFELY
485 
486         return _int;
487     }
.PP
.fi

.SS "int argx::Argx::getArgc () const"

.PP
Get the main options from the \fRmain()\fP function as argc\&. 
.PP
\fBReturns\fP
.RS 4
int Number of params including the executable param 
.RE
.PP

.PP
Definition at line \fB636\fP of file \fBArgx\&.cpp\fP\&.
.nf
637     { return this\->mainArgc; }
.PP
.fi

.PP
References \fBmainArgc\fP\&.
.SS "int argx::Argx::getArgIDPos (const std::string & arg)"

.PP
Get argument using ID\&. 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP Argument to find 
.RE
.PP
\fBReturns\fP
.RS 4
int Argument position 
.RE
.PP

.PP
Definition at line \fB53\fP of file \fBArgx\&.cpp\fP\&.
.nf
54     {
55         ARGXOptions option = this\->getOption(arg);
56         
57         int argPos = this\->getArgPos(option\&.param);
58         int shortArgPos = this\->getArgPos(option\&.sparam);
59 
60         if (argPos >= 0) return argPos;
61         if (shortArgPos >= 0) return shortArgPos;
62 
63         return \-1;
64     }
.PP
.fi

.PP
References \fBgetArgPos()\fP, \fBgetOption()\fP, \fBargx::ARGXOptions::param\fP, and \fBargx::ARGXOptions::sparam\fP\&.
.SS "int argx::Argx::getArgPos (const std::string & arg)"

.PP
Get argument position with specified \fRarg\fP 
.PP
\fBParameters\fP
.RS 4
\fIarg\fP Find argument 
.RE
.PP
\fBReturns\fP
.RS 4
int Return position of found \fRarg\fP from the options 
.RE
.PP

.PP
Definition at line \fB79\fP of file \fBArgx\&.cpp\fP\&.
.nf
80     {
81         if (!this\->mainArgs)
82             return \-2;
83 
84         for (size_t i = 0; i < this\->mainArgs\->size(); ++i)
85         {
86             if (this\->mainArgs\->at(i) == arg)
87                 return i;
88         }
89 
90         return \-1;
91     }
.PP
.fi

.PP
References \fBmainArgs\fP\&.
.PP
Referenced by \fBgetArgIDPos()\fP, and \fBgetSubValue()\fP\&.
.SS "std::string argx::Argx::getID () const"

.PP
Get \fBArgx\fP ID\&. 
.PP
\fBReturns\fP
.RS 4
std::string \fBArgx\fP ID 
.RE
.PP

.PP
Definition at line \fB642\fP of file \fBArgx\&.cpp\fP\&.
.nf
643     { return this\->id; }
.PP
.fi

.SS "std::vector< std::string > argx::Argx::getMainArgs () const"

.PP
Get main arguments from \fRmain()\fP function \fRargv\fP 
.PP
\fBReturns\fP
.RS 4
std::vector<std::string> Vector of strings for main arguments from \fRargv\fP 
.RE
.PP

.PP
Definition at line \fB633\fP of file \fBArgx\&.cpp\fP\&.
.nf
634     { return *this\->mainArgs; }
.PP
.fi

.PP
References \fBmainArgs\fP\&.
.PP
Referenced by \fBgetSubValue()\fP\&.
.SS "\fBARGXOptions\fP argx::Argx::getOption (const std::string & id)"

.PP
Get Options from specified ID\&. 
.PP
\fBParameters\fP
.RS 4
\fIid\fP ID to find 
.br
\fI\fBARGXOptions\fP\fP Option information 
.RE
.PP

.PP
Definition at line \fB572\fP of file \fBArgx\&.cpp\fP\&.
.nf
573     {
574         for (const auto &x : this\->options)
575             if (x\&.id == id) return x;
576 
577         return {};
578     }
.PP
.fi

.PP
References \fBoptions\fP\&.
.PP
Referenced by \fBgetArgIDPos()\fP, and \fBgetSubValue()\fP\&.
.SS "std::vector< \fBARGXOptions\fP > argx::Argx::getOptions () const"

.PP
Get main set options as \fBARGXOptions\fP\&. 
.PP
\fBReturns\fP
.RS 4
std::vector<ARGXOptions> Options to return 
.RE
.PP

.PP
Definition at line \fB639\fP of file \fBArgx\&.cpp\fP\&.
.nf
640     { return this\->options; }
.PP
.fi

.PP
References \fBoptions\fP\&.
.SS "\fBARGXParam\fP argx::Argx::getParam (const std::string & id)"

.PP
Get the param from \fRid\fP 
.PP
\fBParameters\fP
.RS 4
\fIid\fP The ID to get 
.RE
.PP
\fBReturns\fP
.RS 4
\fBARGXParam\fP Returnted parameter to get 
.RE
.PP

.PP
Definition at line \fB171\fP of file \fBArgx\&.cpp\fP\&.
.nf
172     {
173         if (this\->mainArgc <= 1) return {};
174 
175         ARGXParam result;
176 
177         // First, check if this is a top\-level option
178         for (const auto &opt : this\->options)
179         {
180             if (opt\&.id == id)
181             {
182                 // Find the position of the main option in arguments
183                 int mainOptionPos = \-1;
184 
185                 for (size_t i = 0; i < this\->mainArgs\->size(); ++i)
186                 {
187                     if ((*this\->mainArgs)[i] == opt\&.param || (*this\->mainArgs)[i] == opt\&.sparam)
188                     {
189                         result\&.exists = true;
190                         mainOptionPos = i;
191                         break;
192                     }
193                 }
194 
195                 if (result\&.exists)
196                 {
197                     if (opt\&.hasSubParams || opt\&.hasAnySubParams)
198                     {
199                         // Check each sub\-parameter
200                         for (const auto &sub : opt\&.subParams)
201                         {
202                             bool subMatched = false;
203 
204                             // Look for sub\-parameters after the main option
205                             for (size_t i = mainOptionPos + 1; i < this\->mainArgs\->size(); ++i)
206                             {
207                                 if ((*this\->mainArgs)[i] == sub\&.param || (*this\->mainArgs)[i] == sub\&.sparam)
208                                 {
209                                     subMatched = true;
210                                     break;
211                                 }
212                             }
213 
214                             result\&.subExists\&.push_back(subMatched);
215                         }
216                     }
217 
218                     return result;
219                 }
220             }
221         }
222 
223         // If not found as top\-level, check if it's a sub\-parameter
224         for (const auto &opt : this\->options)
225         {
226             // Find if the parent option exists and get its position
227             size_t parentPos = \-1;
228 
229             for (size_t i = 0; i < this\->mainArgs\->size(); ++i)
230             {
231                 if ((*this\->mainArgs)[i] == opt\&.param || (*this\->mainArgs)[i] == opt\&.sparam)
232                 {
233                     parentPos = i;
234                     break;
235                 }
236             }
237 
238             if (parentPos > \-1 && (opt\&.hasSubParams || opt\&.hasAnySubParams))
239             {
240                 // Check if the requested sub\-parameter exists after the parent
241                 for (const auto &sub : opt\&.subParams)
242                 {
243                     if (sub\&.id == id)
244                     {
245                         for (size_t i = parentPos + 1 ; i < this\->mainArgs\->size(); ++i)
246                         {
247                             if ((*this\->mainArgs)[i] == sub\&.param || (*this\->mainArgs)[i] == sub\&.sparam)
248                             {
249                                 result\&.exists = true;
250                                 break;
251                             }
252                         }
253 
254                         if (!result\&.exists && parentPos + 1 < this\->mainArgs\->size())
255                         {
256                             std::string nextArg = (*this\->mainArgs)[parentPos + 1];
257 
258                             if (nextArg == sub\&.param || nextArg == sub\&.sparam) result\&.exists = true;
259                         }
260 
261                         // Handle any sub\-sub\-parameters if they exist
262                         if (result\&.exists && (sub\&.hasSubParams || sub\&.hasAnySubParams))
263                         {
264                             for (const auto &subsub : sub\&.subParams)
265                             {
266                                 bool subsubMatched = false;
267 
268                                 for (size_t i = 0; i < this\->mainArgs\->size(); ++i)
269                                 {
270                                     if ((*this\->mainArgs)[i] == subsub\&.param || (*this\->mainArgs)[i] == subsub\&.sparam)
271                                     {
272                                         subsubMatched = true;
273                                         break;
274                                     }
275                                 }
276 
277                                 result\&.subExists\&.push_back(subsubMatched);
278                             }
279                         }
280 
281                         return result;
282                     }
283                 }
284             }
285         }
286 
287         return result;
288     }
.PP
.fi

.PP
References \fBargx::ARGXParam::exists\fP, \fBmainArgc\fP, \fBmainArgs\fP, \fBoptions\fP, and \fBargx::ARGXParam::subExists\fP\&.
.SS "bool argx::Argx::getSubParam (const \fBargx::ARGXParam\fP & param, const std::string & id)"

.PP
Get the sub-param from \fRid\fP 
.PP
\fBParameters\fP
.RS 4
\fIparam\fP Original param 
.br
\fIid\fP The ID to get 
.RE
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP

.PP
Definition at line \fB290\fP of file \fBArgx\&.cpp\fP\&.
.nf
291     { return this\->paramExists(id) && param\&.subExists[this\->findParam(id)]; }
.PP
.fi

.PP
References \fBfindParam()\fP, \fBparamExists()\fP, and \fBargx::ARGXParam::subExists\fP\&.
.SS "std::vector< std::string > argx::Argx::getSubValue (const std::string & id)"

.PP
Get sub-parameter values, starting from the first value found until the first found value that corresponds to a registered parameter\&. 
.PP
\fBParameters\fP
.RS 4
\fIid\fP ID to find to get sub-value 
.RE
.PP
\fBReturns\fP
.RS 4
std::vector<std::string> Values found from first to last 
.RE
.PP

.PP
Definition at line \fB580\fP of file \fBArgx\&.cpp\fP\&.
.nf
581     {
582         // Use `Argx::getArgPos()` function for sub\-params
583         size_t idPos = this\->getArgPos(id) + 1;
584 
585         if (idPos < 0 || idPos == std::string::npos)
586             return {this\->getOption(id)\&.defaultValue};
587 
588         std::vector<std::string> values;
589 
590         for (size_t i = idPos ; i < this\->getMainArgs()\&.size() ; i++)
591         {
592             // End of the sub\-parameter finding
593             // Assume the search is done due to an existsing sub\-param
594             if (i != idPos && this\->subParamExists(this\->getMainArgs()[i]))
595                 break;
596 
597             values\&.emplace_back(this\->getMainArgs()[i]);
598         }
599 
600         std::string defaultValue;
601 
602         {
603             bool breakOut = false;
604 
605             for (size_t i = 0; i < this\->mainArgs\->size(); ++i)
606             {
607                 for (size_t j = 0 ; j < this\->options\&.size() ; ++j)
608                 {
609                     if (this\->options[i]\&.subParams\&.size() > j)
610                     {
611                         if (this\->options[i]\&.subParams[j]\&.id == id)
612                         {
613                             defaultValue = this\->options[i]\&.subParams[j]\&.defaultValue;
614 
615 
616                             breakOut = true;
617 
618                             break;
619                         }
620                     }
621                 }
622 
623                 if (breakOut) break;
624             }
625         }
626 
627         if (values\&.empty())
628             values\&.emplace_back(defaultValue);
629 
630         return values;
631     }
.PP
.fi

.PP
References \fBargx::ARGXOptions::defaultValue\fP, \fBgetArgPos()\fP, \fBgetMainArgs()\fP, \fBgetOption()\fP, \fBmainArgs\fP, \fBoptions\fP, and \fBsubParamExists()\fP\&.
.SS "int argx::Argx::getWrongArgs (const std::vector< std::string > & argv)"

.PP
Get the incorrect arguments and sub-arguments that were not registered\&. 
.PP
\fBParameters\fP
.RS 4
\fIargv\fP Main arguments from argv 
.RE
.PP
\fBReturns\fP
.RS 4
int Argument position 
.RE
.PP

.PP
Definition at line \fB395\fP of file \fBArgx\&.cpp\fP\&.
.nf
396     {
397         int pos = 1; // skip program name
398         bool isNormalParam = true;
399 
400         while (pos < (int)argv\&.size())
401         {
402             const std::string &arg = argv[pos];
403 
404             // Find matching top\-level option
405             const ARGXOptions *matched = nullptr;
406 
407             for (const auto &opt : this\->options)
408             {
409                 if (arg == opt\&.param || arg == opt\&.sparam)
410                 {
411                     matched = &opt;
412                     break;
413                 }
414             }
415             
416             // unknown top\-level arg
417             if (!matched) return (isNormalParam ? pos : \-pos);
418 
419             // matched a top\-level option
420             isNormalParam = true;
421 
422             if (matched\->hasSubParams || matched\->hasAnySubParams)
423             {
424                 isNormalParam = false;
425 
426                 int scanPos = pos + 1;
427 
428                 while (scanPos < (int)argv\&.size())
429                 {
430                     const std::string &nextArg = argv[scanPos];
431 
432                     // Is it a declared subparam for this option?
433                     bool isSub = false;
434 
435                     for (const auto &subOpt : matched\->subParams)
436                     {
437                         if (nextArg == subOpt\&.param || nextArg == subOpt\&.sparam)
438                         {
439                             isSub = true;
440                             break;
441                         }
442                     }
443 
444                     if (isSub)
445                     {
446                         // Consume that subparam and continue scanning
447                         pos = scanPos;
448                         ++scanPos;
449 
450                         continue;
451                     }
452 
453                     // If not a subparam, is it a global option? (do **NOT** consume it)
454                     bool isGlobalOpt = false;
455 
456                     for (const auto &globalOpt : this\->options)
457                     {
458                         if (nextArg == globalOpt\&.param || nextArg == globalOpt\&.sparam)
459                         {
460                             isGlobalOpt = true;
461 
462                             break;
463                         }
464                     }
465 
466                     // valid global option follows; stop subparam scan and let outer loop handle it
467                     if (isGlobalOpt) break;
468 
469                     // neither subparam nor global option; it's an invalid sub\-parameter token
470                     return \-scanPos;
471                 }
472             }
473 
474             ++pos;
475         }
476 
477         // If nothing wrong found; return your existing success codes
478         if (isNormalParam) return (this\->mainArgs\->size() > 2 ? 2 : 1);
479         else return (this\->mainArgs\->size() > 2 ? \-2 : \-1);
480     }
.PP
.fi

.PP
References \fBargx::ARGXOptions::hasAnySubParams\fP, \fBargx::ARGXOptions::hasSubParams\fP, \fBmainArgs\fP, \fBoptions\fP, and \fBargx::ARGXOptions::subParams\fP\&.
.SS "bool argx::Argx::hasTag (const std::string & id, const std::string & tag)"

.PP
Check if the \fRtag\fP exists in option with ID of \fRid\fP 
.PP
\fBParameters\fP
.RS 4
\fIid\fP ID from option 
.br
\fItag\fP Tag to find 
.RE
.PP
\fBReturns\fP
.RS 4
bool Return false if there is no match, else, return true 
.RE
.PP

.PP
Definition at line \fB159\fP of file \fBArgx\&.cpp\fP\&.
.nf
160     {
161         int paramID = this\->findParam(id);
162 
163         if (paramID < 0) return false;
164         
165         // Validate if tag from options is equal to this tag from function param
166         if (this\->options[paramID]\&.tag == tag) return true;
167 
168         return false;
169     }
.PP
.fi

.PP
References \fBfindParam()\fP, and \fBoptions\fP\&.
.SS "bool argx::Argx::paramExists (const std::string & id)"

.PP
Get if param exists in the param options\&. 
.PP
\fBParameters\fP
.RS 4
\fIid\fP ID to get 
.RE
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP

.PP
Definition at line \fB142\fP of file \fBArgx\&.cpp\fP\&.
.nf
143     {
144         if (this\->findParam(id) >= 0) return true;
145 
146         return false;
147     }
.PP
.fi

.PP
References \fBfindParam()\fP\&.
.PP
Referenced by \fBgetSubParam()\fP\&.
.SS "std::string argx::Argx::paramToID (const std::string & param)"

.PP
Normal parameter or sub-paramter to its corresponding ID\&. 
.PP
\fBParameters\fP
.RS 4
\fIparam\fP Parameter value or name 
.RE
.PP
\fBReturns\fP
.RS 4
std::string ID of the param or sub-param 
.RE
.PP

.PP
Definition at line \fB66\fP of file \fBArgx\&.cpp\fP\&.
.nf
67     {
68         std::string id;
69 
70         for (const auto &option : this\->options)
71         {
72             if (option\&.param == param || option\&.sparam == param)
73                 return option\&.id;
74         }
75 
76         return id;
77     }
.PP
.fi

.PP
References \fBid\fP, and \fBoptions\fP\&.
.SS "bool argx::Argx::subParamExists (const std::string & id)"

.PP
Get if sub-param exists in the param options\&. 
.PP
\fBParameters\fP
.RS 4
\fIid\fP ID to get 
.RE
.PP
\fBReturns\fP
.RS 4
bool 
.RE
.PP

.PP
Definition at line \fB149\fP of file \fBArgx\&.cpp\fP\&.
.nf
150     {
151         for (const auto &p : this\->options)
152         {
153             if (p\&.sparam == id) return true;
154         }
155         
156         return false;
157     }
.PP
.fi

.PP
References \fBoptions\fP\&.
.PP
Referenced by \fBgetSubValue()\fP\&.
.SH "Member Data Documentation"
.PP 
.SS "std::string argx::Argx::id\fR [private]\fP"

.PP
Definition at line \fB20\fP of file \fBArgx\&.hpp\fP\&.
.PP
Referenced by \fBArgx()\fP, and \fBparamToID()\fP\&.
.SS "unsigned int argx::Argx::mainArgc\fR [static]\fP, \fR [private]\fP"

.PP
Definition at line \fB25\fP of file \fBArgx\&.hpp\fP\&.
.PP
Referenced by \fBArgx()\fP, \fBgetArgc()\fP, and \fBgetParam()\fP\&.
.SS "std::vector< std::string > * argx::Argx::mainArgs = nullptr\fR [static]\fP, \fR [private]\fP"

.PP
Definition at line \fB23\fP of file \fBArgx\&.hpp\fP\&.
.PP
Referenced by \fBArgx()\fP, \fB~Argx()\fP, \fBfindParam()\fP, \fBgetArgPos()\fP, \fBgetMainArgs()\fP, \fBgetParam()\fP, \fBgetSubValue()\fP, and \fBgetWrongArgs()\fP\&.
.SS "std::vector< \fBARGXOptions\fP > argx::Argx::options\fR [static]\fP, \fR [private]\fP"

.PP
Definition at line \fB22\fP of file \fBArgx\&.hpp\fP\&.
.PP
Referenced by \fBadd()\fP, \fBcompareArgs()\fP, \fBcreateDocs()\fP, \fBfindParam()\fP, \fBgetOption()\fP, \fBgetOptions()\fP, \fBgetParam()\fP, \fBgetSubValue()\fP, \fBgetWrongArgs()\fP, \fBhasTag()\fP, \fBparamToID()\fP, and \fBsubParamExists()\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for Argx from the source code\&.
